{
  "id": "guide/http-optimize-server-interaction",
  "title": "HTTP - Optimize server interaction with debouncing",
  "contents": "\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/http-optimize-server-interaction.md?message=docs%3A%20请简述你的修改...\" aria-label=\"提供编辑建议\" title=\"提供编辑建议\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"http---optimize-server-interaction-with-debouncing\">HTTP - Optimize server interaction with debouncing<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-optimize-server-interaction#http---optimize-server-interaction-with-debouncing\"><i class=\"material-icons\">link</i></a></h1>\n<h1 id=\"http---通过防抖优化服务器交互\">HTTP - 通过防抖优化服务器交互<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-optimize-server-interaction#http---通过防抖优化服务器交互\"><i class=\"material-icons\">link</i></a></h1>\n<p>If you need to make an HTTP request in response to user input, it's not efficient to send a request for every keystroke. It's better to wait until the user stops typing and then send a request. This technique is known as debouncing.</p>\n<p>如果你需要发一个 HTTP 请求来响应用户的输入，那么每次按键就发送一个请求的效率显然不高。最好等用户停止输入后再发送请求。这种技术叫做防抖。</p>\n<h2 id=\"implement-debouncing\">Implement debouncing<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-optimize-server-interaction#implement-debouncing\"><i class=\"material-icons\">link</i></a></h2>\n<h2 id=\"实现防抖\">实现防抖<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-optimize-server-interaction#实现防抖\"><i class=\"material-icons\">link</i></a></h2>\n<p>Consider the following template, which lets a user enter a search term to find a package by name. When the user enters a name in a search-box, the <code>PackageSearchComponent</code> sends a search request for a package with that name to the package search API.</p>\n<p>考虑下面这个模板，它让用户输入一个搜索词来按名字查找包。当用户在搜索框中输入名字时，<code>PackageSearchComponent</code> 就会把这个根据名字搜索包的请求发给包搜索 API。</p>\n<code-example header=\"app/package-search/package-search.component.html (search)\" path=\"http/src/app/package-search/package-search.component.html\" region=\"search\">\n&#x3C;input type=\"text\" (keyup)=\"search(getValue($event))\" id=\"name\" placeholder=\"Search\"/>\n\n&#x3C;ul>\n  &#x3C;li *<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a>=\"let package of packages$ | async\">\n    &#x3C;strong>{{package.name}} v.{{package.version}}&#x3C;/strong> -\n    &#x3C;em>{{package.description}}&#x3C;/em>\n  &#x3C;/li>\n&#x3C;/ul>\n\n</code-example>\n<p>Here, the <code>keyup</code> event binding sends every keystroke to the component's <code>search()</code> method.</p>\n<p>在这里，<code>keyup</code> 事件绑定会将每个按键都发送到组件的 <code>search()</code> 方法。</p>\n<div class=\"alert is-helpful\">\n<p>The type of <code>$event.target</code> is only <code>EventTarget</code> in the template.\nIn the <code>getValue()</code> method, the target is cast to an <code>HTMLInputElement</code> to let type-safe have access to its <code>value</code> property.</p>\n<code-example path=\"http/src/app/package-search/package-search.component.ts\" region=\"getValue\">\ngetValue(event: <a href=\"api/router/Event\" class=\"code-anchor\">Event</a>): string {\n  return (event.target as HTMLInputElement).value;\n}\n\n</code-example>\n</div>\n<p>The following snippet implements debouncing for this input using RxJS operators.</p>\n<p>下面的代码片段使用 RxJS 的操作符为这个输入实现了防抖。</p>\n<code-example header=\"app/package-search/package-search.component.ts (excerpt)\" path=\"http/src/app/package-search/package-search.component.ts\" region=\"debounce\">\nwithRefresh = false;\npackages$!: Observable&#x3C;NpmPackageInfo[]>;\nprivate searchText$ = new Subject&#x3C;string>();\n\nsearch(packageName: string) {\n  this.searchText$.next(packageName);\n}\n\nngOnInit() {\n  this.packages$ = this.searchText$.pipe(\n    debounceTime(500),\n    distinctUntilChanged(),\n    switchMap(packageName =>\n      this.searchService.search(packageName, this.withRefresh))\n  );\n}\n\nconstructor(private searchService: PackageSearchService) { }\n\n\n</code-example>\n<p>The <code>searchText$</code> is the sequence of search-box values coming from the user.\nIt's defined as an RxJS <code>Subject</code>, which means it is a multicasting <code>Observable</code> that can also emit values for itself by calling <code>next(value)</code>, as happens in the <code>search()</code> method.</p>\n<p><code>searchText$</code> 是来自用户的搜索框值的序列。它被定义为 RxJS <code>Subject</code> 类型，这意味着它是一个多播 <code>Observable</code>，它还可以通过调用 <code>next(value)</code> 来自行发出值，就像在 <code>search()</code> 方法中一样。</p>\n<p>Rather than forward every <code>searchText</code> value directly to the injected <code>PackageSearchService</code>, the code in <code>ngOnInit()</code> pipes search values through three operators, so that a search value reaches the service only if it's a new value and the user stopped typing.</p>\n<p>除了把每个 <code>searchText</code> 的值都直接转发给 <code>PackageSearchService</code> 之外，<code>ngOnInit()</code> 中的代码还通过下列三个操作符对这些搜索值进行<em>管道</em>处理，以便只有当它是一个新值并且用户已经停止输入时，要搜索的值才会抵达该服务。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">RxJS operators</th>\n<th align=\"left\">Details</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\">RxJS 操作符</td>\n<td align=\"left\">详情</td>\n</tr>\n<tr>\n<td align=\"left\"><code>debounceTime(500)</code>⁠</td>\n<td align=\"left\">Wait for the user to stop typing, which is 1/2 second in this case.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>debounceTime(500)</code>⁠</td>\n<td align=\"left\">等待用户停止输入，本例中为 1/2 秒。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>distinctUntilChanged()</code></td>\n<td align=\"left\">Wait until the search text changes.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>distinctUntilChanged()</code></td>\n<td align=\"left\">等待搜索文本发生变化。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>switchMap()</code>⁠</td>\n<td align=\"left\">Send the search request to the service.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>switchMap()</code>⁠</td>\n<td align=\"left\">将搜索请求发送到服务。</td>\n</tr>\n</tbody>\n</table>\n<p>The code sets <code>packages$</code> to this re-composed <code>Observable</code> of search results.\nThe template subscribes to <code>packages$</code> with the <a href=\"api/common/AsyncPipe\">AsyncPipe</a> and displays search results as they arrive.</p>\n<p>这些代码把 <code>packages$</code> 设置成了使用搜索结果组合出的 <code>Observable</code> 对象。模板中使用 <a href=\"api/common/AsyncPipe\">AsyncPipe</a> 订阅了 <code>packages$</code>，一旦搜索结果的值发回来了，就显示这些搜索结果。</p>\n<div class=\"alert is-helpful\">\n<p>See <a href=\"guide/http-interceptor-use-cases#cache-refresh\">Using interceptors to request multiple values</a> for more about the <code>withRefresh</code> option.</p>\n</div>\n<h2 id=\"using-the-switchmap-operator\">Using the <code>switchMap()</code> operator<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-optimize-server-interaction#using-the-switchmap-operator\"><i class=\"material-icons\">link</i></a></h2>\n<h2 id=\"使用-switchmap-操作符\">使用 <code>switchMap()</code> 操作符<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-optimize-server-interaction#使用-switchmap-操作符\"><i class=\"material-icons\">link</i></a></h2>\n<p>The <code>switchMap()</code> operator takes a function argument that returns an <code>Observable</code>.\nIn the example, <code>PackageSearchService.search</code> returns an <code>Observable</code>, as other data service methods do.\nIf a previous search request is still in-flight, such as when the network connection is poor, the operator cancels that request and sends a new one.</p>\n<p><code>switchMap()</code> 操作符接受一个返回 <code>Observable</code> 的函数型参数。在这个例子中，<code>PackageSearchService.search</code> 像其它数据服务方法那样返回一个 <code>Observable</code>。如果先前的搜索请求仍在<em>进行中</em>（如网络连接不良），它将取消该请求并发送新的请求。</p>\n<div class=\"alert is-helpful\">\n<p><strong>NOTE</strong>: <br>\n<code>switchMap()</code> returns service responses in their original request order, even if the server returns them out of order.</p>\n</div>\n<div class=\"alert is-helpful\">\n<p>If you think you'll reuse this debouncing logic, consider moving it to a utility function or into the <code>PackageSearchService</code> itself.</p>\n</div>\n\n  <div class=\"reviewed\">最后复查时间：2/27/2023</div>\n</div>\n\n\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - api/common/AsyncPipe\n - api/common/NgFor\n - api/router/Event\n - guide/http-interceptor-use-cases#cache-refresh\n - guide/http-optimize-server-interaction#http---optimize-server-interaction-with-debouncing\n - guide/http-optimize-server-interaction#http---通过防抖优化服务器交互\n - guide/http-optimize-server-interaction#implement-debouncing\n - guide/http-optimize-server-interaction#using-the-switchmap-operator\n - guide/http-optimize-server-interaction#使用-switchmap-操作符\n - guide/http-optimize-server-interaction#实现防抖\n - https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/http-optimize-server-interaction.md?message=docs%3A%20请简述你的修改...\n-->"
}