{
  "id": "guide/view-encapsulation",
  "title": "View encapsulation",
  "contents": "\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/aio/aio/content/guide/view-encapsulation.md?message=docs%3A%20请简述你的修改...\" aria-label=\"提供编辑建议\" title=\"提供编辑建议\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"view-encapsulation\" translation-result=\"on\">视图封装模式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/view-encapsulation#view-encapsulation\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\" id=\"view-encapsulation\">View encapsulation<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/view-encapsulation#view-encapsulation\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">在 Angular 中，组件的 CSS 样式被封装进了自己的视图中，而不会影响到应用程序的其它部分。</p><p translation-origin=\"off\">In Angular, component CSS styles are encapsulated into the component's view and don't\naffect the rest of the application.</p>\n\n<p translation-result=\"on\">通过在组件的元数据上设置<em>视图封装模式</em>，你可以分别控制<em>每个组件</em>的封装模式。\n可选的封装模式一共有如下几种：</p><p translation-origin=\"off\">To control how this encapsulation happens on a <em>per\ncomponent</em> basis, set the <em>view encapsulation mode</em> in the component metadata.\nChoose from the following modes:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"> <code>ShadowDom</code> 模式使用浏览器内置的 Shadow DOM 实现（参阅 <a href=\"https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM\">Shadow DOM</a>）来为组件的宿主元素附加一个 Shadow DOM。组件的视图被附加到这个 Shadow DOM 中，组件的样式也被包含在这个 Shadow DOM 中。(译注：不进不出，没有样式能进来，组件样式出不去。)</p><p translation-origin=\"off\"><code>ShadowDom</code> view encapsulation uses the browser's built-in shadow DOM implementation (see\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM\">Shadow DOM</a>)\nto attach a shadow DOM to the component's host element, and then puts the component\nview inside that shadow DOM. The component's styles are included within the shadow DOM.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"> <code>Emulated</code> 模式（<strong>默认值</strong>）通过预处理（并改名）CSS 代码来模拟 Shadow DOM 的行为，以达到把 CSS 样式局限在组件视图中的目的。\n更多信息，见<a href=\"guide/view-encapsulation#inspect-generated-css\">附录 1</a>。(译注：只进不出，全局样式能进来，组件样式出不去)</p><p translation-origin=\"off\"><code>Emulated</code> view encapsulation (the default) emulates the behavior of shadow DOM by preprocessing\n(and renaming) the CSS code to effectively scope the CSS to the component's view.\nFor details, see <a href=\"guide/view-encapsulation#inspect-generated-css\">Inspecting generated CSS</a>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"> <code>None</code> 意味着 Angular 不使用视图封装。\nAngular 会把 CSS 添加到全局样式中。而不会应用上前面讨论过的那些作用域规则、隔离和保护等。\n从本质上来说，这跟把组件的样式直接放进 HTML 是一样的。(译注：能进能出。)</p><p translation-origin=\"off\"><code>None</code> means that Angular does no view encapsulation.\nAngular adds the CSS to the global styles.\nThe scoping rules, isolations, and protections discussed earlier don't apply.\nThis mode is essentially the same as pasting the component's styles into the HTML.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">通过组件元数据中的 <code>encapsulation</code> 属性来设置组件封装模式：</p><p translation-origin=\"off\">To set the component's encapsulation mode, use the <code>encapsulation</code> property in the component metadata:</p>\n\n<code-example path=\"component-styles/src/app/quest-summary.component.ts\" region=\"encapsulation.shadow\" header=\"src/app/quest-summary.component.ts\">\n// warning: not all browsers support shadow DOM encapsulation at this time\nencapsulation: <a href=\"api/core/ViewEncapsulation#ShadowDom\" class=\"code-anchor\">ViewEncapsulation.ShadowDom</a>\n\n</code-example>\n<p translation-result=\"on\"><code>ShadowDom</code> 模式只适用于提供了原生 Shadow DOM 支持的浏览器（参阅 <a href=\"https://caniuse.com/\">Can I use</a> 上的 <a href=\"https://caniuse.com/shadowdomv1\">Shadow DOM v1</a> 部分）。\n它仍然受到很多限制，这就是为什么仿真 (<code>Emulated</code>) 模式是默认选项，并建议将其用于大多数情况。</p><p translation-origin=\"off\"><code>ShadowDom</code> view encapsulation only works on browsers that have built-in support\nfor shadow DOM (see <a href=\"https://caniuse.com/shadowdomv1\">Can I use - Shadow DOM v1</a>).\nThe support is still limited, which is why <code>Emulated</code> view encapsulation is the default mode and recommended in most cases.</p>\n\n<a id=\"inspect-generated-css\"></a>\n<h2 id=\"inspecting-generated-css\" translation-result=\"on\">查看生成的 CSS<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/view-encapsulation#inspecting-generated-css\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"inspecting-generated-css\">Inspecting generated CSS<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/view-encapsulation#inspecting-generated-css\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">当使用默认的仿真模式时，Angular 会对组件的所有样式进行预处理，让它们模仿出标准的 Shadow CSS 作用域规则。</p><p translation-origin=\"off\">When using emulated view encapsulation, Angular preprocesses\nall component styles so that they approximate the standard shadow CSS scoping rules.</p>\n\n<p translation-result=\"on\">在启用了仿真模式的 Angular 应用的 DOM 树中，每个 DOM 元素都被加上了一些额外的属性。</p><p translation-origin=\"off\">In the DOM of a running Angular application with emulated view\nencapsulation enabled, each DOM element has some extra attributes\nattached to it:</p>\n\n<code-example format=\"\">\n&#x3C;hero-details _nghost-pmm-5>\n  &#x3C;h2 _ngcontent-pmm-5>Mister Fantastic&#x3C;/h2>\n  &#x3C;hero-team _ngcontent-pmm-5 _nghost-pmm-6>\n    &#x3C;h3 _ngcontent-pmm-6>Team&#x3C;/h3>\n  &#x3C;/hero-team>\n&#x3C;/hero-detail>\n</code-example>\n<p translation-result=\"on\">生成出的属性分为两种：</p><p translation-origin=\"off\">There are two kinds of generated attributes:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"> 一个元素在原生封装方式下可能是 Shadow DOM 的宿主，在这里被自动添加上一个 <code>_nghost</code> 属性。\n这是组件宿主元素的典型情况。</p><p translation-origin=\"off\">An element that would be a shadow DOM host in native encapsulation has a\ngenerated <code>_nghost</code> attribute. This is typically the case for component host elements.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">   组件视图中的每一个元素，都有一个 <code>_ngcontent</code> 属性，它会标记出该元素属于哪个宿主的模拟 Shadow DOM。</p><p translation-origin=\"off\">An element within a component's view has a <code>_ngcontent</code> attribute\nthat identifies to which host's emulated shadow DOM this element belongs.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">这些属性的具体值并不重要。它们是自动生成的，并且你永远不会在程序代码中直接引用到它们。\n但它们会作为生成的组件样式的目标，就像 DOM 的 <code>&#x3C;head></code> 中一样：</p><p translation-origin=\"off\">The exact values of these attributes aren't important. They are automatically\ngenerated and you should never refer to them in application code. But they are targeted\nby the generated component styles, which are in the <code>&#x3C;head></code> section of the DOM:</p>\n\n<code-example format=\"\">\n[_nghost-pmm-5] {\n  display: block;\n  border: 1px solid black;\n}\n\nh3[_ngcontent-pmm-6] {\n  background-color: white;\n  border: 1px solid #777;\n}\n</code-example>\n<p translation-result=\"on\">这些就是那些样式被处理后的结果，每个选择器都被增加了 <code>_nghost</code> 或 <code>_ngcontent</code> 属性选择器。\n这些额外的选择器实现了本文所描述的这些作用域规则。</p><p translation-origin=\"off\">These styles are post-processed so that each selector is augmented\nwith <code>_nghost</code> or <code>_ngcontent</code> attribute selectors.\nThese extra selectors enable the scoping rules described in this page.</p>\n\n<h2 id=\"mixing-encapsulation-modes\" translation-result=\"on\">混用封装模式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/view-encapsulation#mixing-encapsulation-modes\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"mixing-encapsulation-modes\">Mixing encapsulation modes<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/view-encapsulation#mixing-encapsulation-modes\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">避免混合使用不同视图封装模式的组件。在必要时，你应该仔细想想组件样式之间将如何互动。</p><p translation-origin=\"off\">Avoid mixing components that use different view encapsulation. Where it is necessary, you should be aware of how the component styles will interact.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">带有 <code><a href=\"api/core/ViewEncapsulation#Emulated\" class=\"code-anchor\">ViewEncapsulation.Emulated</a></code> 的组件的样式被添加到文档的 <code>&#x3C;head></code> 中，使它们在整个应用程序中可用，但它们是“范围化”的，因此它们只影响本组件模板中的元素。</p><p translation-origin=\"off\">The styles of components with <code><a href=\"api/core/ViewEncapsulation#Emulated\" class=\"code-anchor\">ViewEncapsulation.Emulated</a></code> are added to the <code>&#x3C;head></code> of the document, making them available throughout the application, but are \"scoped\" so they only affect elements within the component's template.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">带有 <code><a href=\"api/core/ViewEncapsulation#None\" class=\"code-anchor\">ViewEncapsulation.None</a></code> 的组件样式被添加到文档的 <code>&#x3C;head></code> 中，使它们在整个应用程序中可用，并且没有“范围化”，因此它们可以影响应用程序中的任何元素。</p><p translation-origin=\"off\">The styles of components with <code><a href=\"api/core/ViewEncapsulation#None\" class=\"code-anchor\">ViewEncapsulation.None</a></code> are added to the <code>&#x3C;head></code> of the document, making them available throughout the application, and are not \"scoped\" so they can affect any element in the application.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">带有 <code><a href=\"api/core/ViewEncapsulation#ShadowDom\" class=\"code-anchor\">ViewEncapsulation.ShadowDom</a></code> 的组件样式仅添加到 shadow DOM 宿主元素中，这会确保它们仅影响组件模板中的元素。</p><p translation-origin=\"off\">The styles of components with <code><a href=\"api/core/ViewEncapsulation#ShadowDom\" class=\"code-anchor\">ViewEncapsulation.ShadowDom</a></code> are only added to the shadow DOM host, ensuring that they only affect elements within the component's template.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\"><strong><code><a href=\"api/core/ViewEncapsulation#Emulated\" class=\"code-anchor\">ViewEncapsulation.Emulated</a></code> 和 <code><a href=\"api/core/ViewEncapsulation#None\" class=\"code-anchor\">ViewEncapsulation.None</a></code> 组件的所有样式也会添加到每个 <code><a href=\"api/core/ViewEncapsulation#ShadowDom\" class=\"code-anchor\">ViewEncapsulation.ShadowDom</a></code> 组件的 shadow DOM 宿主元素中。</strong></p><p translation-origin=\"off\"><strong>All the styles for <code><a href=\"api/core/ViewEncapsulation#Emulated\" class=\"code-anchor\">ViewEncapsulation.Emulated</a></code> and <code><a href=\"api/core/ViewEncapsulation#None\" class=\"code-anchor\">ViewEncapsulation.None</a></code> components are also added to the shadow DOM host of each <code><a href=\"api/core/ViewEncapsulation#ShadowDom\" class=\"code-anchor\">ViewEncapsulation.ShadowDom</a></code> component.</strong></p>\n\n<p translation-result=\"on\">其结果是使用 <code><a href=\"api/core/ViewEncapsulation#None\" class=\"code-anchor\">ViewEncapsulation.None</a></code> 的组件样式将影响 shadow DOM 中的那些可匹配元素。</p><p translation-origin=\"off\">The result is that styling for components with <code><a href=\"api/core/ViewEncapsulation#None\" class=\"code-anchor\">ViewEncapsulation.None</a></code> will affect matching elements within the shadow DOM.</p>\n\n<p translation-result=\"on\">这种方法乍一看有点反直觉，但如果没有它，带有 <code><a href=\"api/core/ViewEncapsulation#None\" class=\"code-anchor\">ViewEncapsulation.None</a></code> 的组件将无法在带有 <code><a href=\"api/core/ViewEncapsulation#ShadowDom\" class=\"code-anchor\">ViewEncapsulation.ShadowDom</a></code> 的组件中生效，因为其样式将不可用。</p><p translation-origin=\"off\">This approach may seem counter-intuitive at first, but without it a component with <code><a href=\"api/core/ViewEncapsulation#None\" class=\"code-anchor\">ViewEncapsulation.None</a></code> could not be used within a component with <code><a href=\"api/core/ViewEncapsulation#ShadowDom\" class=\"code-anchor\">ViewEncapsulation.ShadowDom</a></code>, since its styles would not be available.</p>\n\n<h3 id=\"examples\" translation-result=\"on\">例子<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/view-encapsulation#examples\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"examples\">Examples<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/view-encapsulation#examples\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">本节展示了一些具有不同 <code><a href=\"api/core/ViewEncapsulation\" class=\"code-anchor\">ViewEncapsulation</a></code> 的组件样式如何互动的例子。</p><p translation-origin=\"off\">This section shows examples of how the styling of components with different <code><a href=\"api/core/ViewEncapsulation\" class=\"code-anchor\">ViewEncapsulation</a></code> interact.</p>\n\n<p translation-result=\"on\">请参阅<live-example nodownload=\"\"></live-example>来自行试用这些组件。</p><p translation-origin=\"off\">See the <live-example nodownload=\"\"></live-example> to try out these components yourself.</p>\n\n<h4 id=\"no-encapsulation\" translation-result=\"on\">无封装<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/view-encapsulation#no-encapsulation\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\" id=\"no-encapsulation\">No encapsulation<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/view-encapsulation#no-encapsulation\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">第一个例子展示了一个具有 <code><a href=\"api/core/ViewEncapsulation#None\" class=\"code-anchor\">ViewEncapsulation.None</a></code> 的组件。此组件将其模板中的元素染为红色。</p><p translation-origin=\"off\">The first example shows a component that has <code><a href=\"api/core/ViewEncapsulation#None\" class=\"code-anchor\">ViewEncapsulation.None</a></code>. This component colors its template elements red.</p>\n\n<code-example path=\"view-encapsulation/src/app/no-encapsulation.component.ts\" header=\"src/app/no-encapsulation.component.ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-no-encapsulation',\n  template: `\n    &#x3C;h2>None&#x3C;/h2>\n    &#x3C;div class=\"none-message\">No encapsulation&#x3C;/div>\n  `,\n  styles: ['h2, .none-message { color: red; }'],\n  encapsulation: <a href=\"api/core/ViewEncapsulation#None\" class=\"code-anchor\">ViewEncapsulation.None</a>,\n})\nexport class NoEncapsulationComponent { }\n\n\n</code-example>\n<blockquote>\n</blockquote>\n<p translation-result=\"on\">Angular 会将此组件的样式作为全局样式添加到文档的 <code>&#x3C;head></code> 中。</p><p translation-origin=\"off\">Angular adds the styles for this component as global styles to the <code>&#x3C;head></code> of the document.</p>\n\n<p translation-result=\"on\"><strong>Angular 还会将这些样式添加到所有 shadow DOM 宿主元素中。</strong>因此，这些样式在整个应用程序中都是可用的。</p><p translation-origin=\"off\"><strong>Angular also adds the styles to all shadow DOM hosts.</strong> Therefore, the styles are available throughout the application.</p>\n\n<img src=\"generated/images/guide/view-encapsulation/no-encapsulation.png\" alt=\"component with no encapsulation\" width=\"500\" height=\"101\">\n<h4 id=\"emulated-encapsulation\" translation-result=\"on\">模拟封装<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/view-encapsulation#emulated-encapsulation\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\" id=\"emulated-encapsulation\">Emulated encapsulation<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/view-encapsulation#emulated-encapsulation\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">第二个例子展示了一个具有 <code><a href=\"api/core/ViewEncapsulation#Emulated\" class=\"code-anchor\">ViewEncapsulation.Emulated</a></code> 的组件。此组件将其模板元素染为绿色。</p><p translation-origin=\"off\">The second example shows a component that has <code><a href=\"api/core/ViewEncapsulation#Emulated\" class=\"code-anchor\">ViewEncapsulation.Emulated</a></code>. This component colors its template elements green.</p>\n\n<code-example path=\"view-encapsulation/src/app/emulated-encapsulation.component.ts\" header=\"src/app/emulated-encapsulation.component.ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-emulated-encapsulation',\n  template: `\n    &#x3C;h2>Emulated&#x3C;/h2>\n    &#x3C;div class=\"emulated-message\">Emulated encapsulation&#x3C;/div>\n    &#x3C;app-no-encapsulation>&#x3C;/app-no-encapsulation>\n  `,\n  styles: ['h2, .emulated-message { color: green; }'],\n  encapsulation: <a href=\"api/core/ViewEncapsulation#Emulated\" class=\"code-anchor\">ViewEncapsulation.Emulated</a>,\n})\nexport class EmulatedEncapsulationComponent { }\n\n\n</code-example>\n<blockquote>\n</blockquote>\n<p translation-result=\"on\">与 <code><a href=\"api/core/ViewEncapsulation#None\" class=\"code-anchor\">ViewEncapsulation.None</a></code> 类似，Angular 会将此组件的样式添加到文档的 <code>&#x3C;head></code> 以及所有 shadow DOM 宿主元素中。但在这里，这些样式被<a href=\"guide/view-encapsulation#inspecting-generated-css\">“检查生成的 CSS”</a> 中所讲的属性“范围化”了。</p><p translation-origin=\"off\">Similar to <code><a href=\"api/core/ViewEncapsulation#None\" class=\"code-anchor\">ViewEncapsulation.None</a></code>, Angular adds the styles for this component to the <code>&#x3C;head></code> of the document, and to all the shadow DOM hosts.\nBut in this case, the styles are \"scoped\" by the attributes described in <a href=\"guide/view-encapsulation#inspecting-generated-css\">\"Inspecting generated CSS\"</a>.</p>\n\n<p translation-result=\"on\">因此，只有直接在该组件模板中的元素才会匹配其样式。由于来自 <code>EmulatedEncapsulationComponent</code> 的样式更具特异性，因此它们会覆盖来自 <code>NoEncapsulationComponent</code> 的全局样式。</p><p translation-origin=\"off\">Therefore, only the elements directly within this component's template will match its styles.\nSince the \"scoped\" styles from the <code>EmulatedEncapsulationComponent</code> are very specific, they override the global styles from the <code>NoEncapsulationComponent</code>.</p>\n\n<p translation-result=\"on\">在此例子中，<code>EmulatedEncapsulationComponent</code> 包含 <code>NoEncapsulationComponent</code> 。\n<code>NoEncapsulationComponent</code> 会按预期般设置样式，因为这些范围化样式与其模板中的元素不匹配。</p><p translation-origin=\"off\">In this example, the <code>EmulatedEncapsulationComponent</code> contains a <code>NoEncapsulationComponent</code>.\nThe <code>NoEncapsulationComponent</code> is styled as expected because the scoped styles do not match elements in its template.</p>\n\n<img src=\"generated/images/guide/view-encapsulation/emulated-encapsulation.png\" alt=\"component with no encapsulation\" width=\"500\" height=\"207\">\n<h4 id=\"shadow-dom-encapsulation\" translation-result=\"on\">Shadow DOM 封装<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/view-encapsulation#shadow-dom-encapsulation\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\" id=\"shadow-dom-encapsulation\">Shadow DOM encapsulation<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/view-encapsulation#shadow-dom-encapsulation\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">第三个例子展示了一个具有 <code><a href=\"api/core/ViewEncapsulation#ShadowDom\" class=\"code-anchor\">ViewEncapsulation.ShadowDom</a></code> 的组件。此组件将其模板元素染为蓝色。</p><p translation-origin=\"off\">The third example shows a component that has <code><a href=\"api/core/ViewEncapsulation#ShadowDom\" class=\"code-anchor\">ViewEncapsulation.ShadowDom</a></code>. This component colors its template elements blue.</p>\n\n<code-example path=\"view-encapsulation/src/app/shadow-dom-encapsulation.component.ts\" header=\"src/app/shadow-dom-encapsulation.component.ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-shadow-dom-encapsulation',\n  template: `\n    &#x3C;h2>ShadowDom&#x3C;/h2>\n    &#x3C;div class=\"shadow-message\">Shadow DOM encapsulation&#x3C;/div>\n    &#x3C;app-emulated-encapsulation>&#x3C;/app-emulated-encapsulation>\n    &#x3C;app-no-encapsulation>&#x3C;/app-no-encapsulation>\n  `,\n  styles: ['h2, .shadow-message { color: blue; }'],\n  encapsulation: <a href=\"api/core/ViewEncapsulation#ShadowDom\" class=\"code-anchor\">ViewEncapsulation.ShadowDom</a>,\n})\nexport class ShadowDomEncapsulationComponent { }\n\n\n</code-example>\n<blockquote>\n</blockquote>\n<p translation-result=\"on\">Angular 仅将此组件的样式添加到 shadow DOM 宿主元素中，因此它们在 shadow DOM 之外是不可见的。</p><p translation-origin=\"off\">Angular adds styles for this component only to the shadow DOM host, so they are not visible outside the shadow DOM.</p>\n\n<p translation-result=\"on\">请注意，Angular 还将 <code>NoEncapsulationComponent</code> 和 <code>ViewEncapsulationComponent</code> 的全局样式添加到了 shadow DOM 宿主元素中，因此这些样式仍然可用于该组件模板中的元素。</p><p translation-origin=\"off\">Note that Angular also adds the global styles from the <code>NoEncapsulationComponent</code> and <code>ViewEncapsulationComponent</code> to the shadow DOM host, so those styles are still available to the elements in the template of this component.</p>\n\n<p translation-result=\"on\">在此例子中， <code>ShadowDomEncapsulationComponent</code> 包含着 <code>NoEncapsulationComponent</code> 和 <code>ViewEncapsulationComponent</code> 。</p><p translation-origin=\"off\">In this example, the <code>ShadowDomEncapsulationComponent</code> contains both a <code>NoEncapsulationComponent</code> and <code>ViewEncapsulationComponent</code>.</p>\n\n<p translation-result=\"on\"><code>ShadowDomEncapsulationComponent</code> 组件添加的样式在该组件的整个 shadow DOM 中都可用，<code>NoEncapsulationComponent</code> 和 <code>ViewEncapsulationComponent</code> 也是如此。</p><p translation-origin=\"off\">The styles added by the <code>ShadowDomEncapsulationComponent</code> component are available throughout the shadow DOM of this component, and so to both the <code>NoEncapsulationComponent</code> and <code>ViewEncapsulationComponent</code>.</p>\n\n<p translation-result=\"on\"><code>EmulatedEncapsulationComponent</code> 具有特定的“范围化”样式，因此该组件模板的样式不受影响。</p><p translation-origin=\"off\">The <code>EmulatedEncapsulationComponent</code> has specific \"scoped\" styles, so the styling of this component's template is unaffected.</p>\n\n<p translation-result=\"on\">但是由于 <code>ShadowDomEncapsulationComponent</code> 中的样式是在全局样式之后添加到 Shadow DOM 宿主中的，因此 <code>h2</code> 样式会覆盖 <code>NoEncapsulationComponent</code> 中的样式。结果是 <code>NoEncapsulationComponent</code> 中的 <code>&#x3C;h2></code> 元素被染为蓝色而不是红色，这可能不符合组件作者的意图。</p><p translation-origin=\"off\">But since styles from <code>ShadowDomEncapsulationComponent</code> are added to the shadow host after the global styles, the <code>h2</code> style overrides the style from the <code>NoEncapsulationComponent</code>.\nThe result is that the <code>&#x3C;h2></code> element in the <code>NoEncapsulationComponent</code> is colored blue rather than red, which may not be what the component author intended.</p>\n\n<img src=\"generated/images/guide/view-encapsulation/shadow-dom-encapsulation.png\" alt=\"component with no encapsulation\" width=\"500\" height=\"413\">\n\n  \n</div>\n\n\n<!-- links to this doc:\n - guide/component-styles\n-->\n<!-- links from this doc:\n - api/core/Component\n - api/core/ViewEncapsulation\n - api/core/ViewEncapsulation#Emulated\n - api/core/ViewEncapsulation#None\n - api/core/ViewEncapsulation#ShadowDom\n - guide/view-encapsulation#emulated-encapsulation\n - guide/view-encapsulation#examples\n - guide/view-encapsulation#inspect-generated-css\n - guide/view-encapsulation#inspecting-generated-css\n - guide/view-encapsulation#mixing-encapsulation-modes\n - guide/view-encapsulation#no-encapsulation\n - guide/view-encapsulation#shadow-dom-encapsulation\n - guide/view-encapsulation#view-encapsulation\n - https://caniuse.com/\n - https://caniuse.com/shadowdomv1\n - https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM\n - https://github.com/ng-docs/angular-cn/edit/aio/aio/content/guide/view-encapsulation.md?message=docs%3A%20请简述你的修改...\n-->"
}